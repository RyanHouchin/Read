<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>READ</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=DM+Sans:wght@300;400;500;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.14/dist/face-api.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; color: #e0e0e0; font-family: 'DM Sans', sans-serif; }
.screen { display: none; min-height: 100vh; }
.screen.active { display: flex; flex-direction: column; align-items: center; }

/* UPLOAD */
#upload-screen { justify-content: center; padding: 40px 20px; }
.upload-zone { border: 1px dashed #333; border-radius: 12px; padding: 60px 40px; text-align: center; cursor: pointer; transition: all 0.3s; max-width: 500px; width: 100%; }
.upload-zone:hover, .upload-zone.dragover { border-color: #00ffaa; background: rgba(0,255,170,0.03); }
.upload-zone h1 { font-family: 'DM Mono', monospace; font-size: 28px; font-weight: 500; letter-spacing: 6px; margin-bottom: 16px; }
.upload-zone p { color: #666; font-size: 14px; margin-bottom: 20px; }
.upload-zone .hint { color: #444; font-size: 12px; font-family: 'DM Mono', monospace; margin-top: 12px; }
.upload-btn { background: transparent; color: #e0e0e0; border: 1px solid #333; padding: 12px 32px; font-family: 'DM Mono', monospace; font-size: 13px; letter-spacing: 2px; cursor: pointer; transition: all 0.3s; }
.upload-btn:hover { border-color: #00ffaa; color: #00ffaa; }
.upload-btn:disabled { opacity: 0.3; cursor: not-allowed; }
input[type="file"] { display: none; }
.model-status { margin-top: 16px; font-family: 'DM Mono', monospace; font-size: 11px; color: #444; }
.model-status.ready { color: #00ffaa; }

/* ANALYSIS */
#analysis-screen { justify-content: center; padding: 40px 20px; }
.analysis-wrap { position: relative; max-width: 500px; width: 100%; }
.analysis-wrap img { width: 100%; display: block; border-radius: 6px; }
.analysis-wrap canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
.scan-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; overflow: hidden; border-radius: 6px; }
.scan-vignette { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.5) 100%); animation: vignetteBreath 3s ease-in-out infinite; }
@keyframes vignetteBreath { 0%,100% { opacity: 0.6; } 50% { opacity: 1; } }
.scan-bracket { position: absolute; width: 50px; height: 50px; }
.scan-bracket.tl { top: 12px; left: 12px; border-top: 2px solid rgba(255,255,255,0.3); border-left: 2px solid rgba(255,255,255,0.3); }
.scan-bracket.br { bottom: 12px; right: 12px; border-bottom: 2px solid rgba(255,255,255,0.3); border-right: 2px solid rgba(255,255,255,0.3); }
.scan-bracket.tr { top: 12px; right: 12px; border-top: 2px solid rgba(255,255,255,0.15); border-right: 2px solid rgba(255,255,255,0.15); }
.scan-bracket.bl { bottom: 12px; left: 12px; border-bottom: 2px solid rgba(255,255,255,0.15); border-left: 2px solid rgba(255,255,255,0.15); }
.scan-label { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); font-family: 'DM Mono', monospace; font-size: 10px; color: rgba(255,255,255,0.5); letter-spacing: 3px; text-align: center; }
@keyframes fadeIn { to { opacity: 1; } }
.analysis-status { margin-top: 20px; font-family: 'DM Mono', monospace; font-size: 12px; color: #666; letter-spacing: 1px; }
.analysis-bar { width: 300px; height: 2px; background: #1a1a1a; margin-top: 12px; border-radius: 1px; overflow: hidden; }
.analysis-bar-fill { height: 100%; background: #00ffaa; transition: width 0.8s ease; width: 0%; }
.error-msg { color: #ff6b6b; font-size: 13px; margin-top: 16px; }

/* REPORT */
#report-screen { padding: 40px 20px 80px; }
.report { max-width: 640px; width: 100%; margin: 0 auto; }
.section { padding: 32px 0; }
.section-divider { height: 1px; background: #1a1a1a; }
.section-num { font-family: 'DM Mono', monospace; font-size: 11px; color: #333; letter-spacing: 2px; }
.section-title { font-family: 'DM Mono', monospace; font-size: 14px; font-weight: 500; letter-spacing: 4px; margin: 4px 0 20px; }

/* Score */
.big-score { font-family: 'DM Mono', monospace; font-size: 72px; font-weight: 300; }
.big-score-sub { font-family: 'DM Mono', monospace; font-size: 18px; color: #444; margin-left: 4px; }
.score-layer { display: flex; align-items: center; gap: 12px; margin: 6px 0; }
.score-layer-label { font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 1px; color: #666; width: 110px; text-transform: uppercase; flex-shrink: 0; }
.score-layer-bar { flex: 1; height: 6px; background: #1a1a1a; border-radius: 3px; overflow: hidden; }
.score-layer-fill { height: 100%; border-radius: 3px; transition: width 1.5s ease; }
.score-layer-val { font-family: 'DM Mono', monospace; font-size: 11px; color: #888; width: 36px; text-align: right; flex-shrink: 0; }
.score-context { font-size: 13px; color: #555; margin-top: 12px; line-height: 1.6; }

/* Projection */
.projection { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
.proj-node { text-align: center; }
.proj-label { font-family: 'DM Mono', monospace; font-size: 9px; letter-spacing: 2px; color: #444; text-transform: uppercase; margin-bottom: 4px; }
.proj-val { font-family: 'DM Mono', monospace; font-size: 36px; font-weight: 300; }
.proj-val.current { color: #888; }
.proj-val.today { color: #aaa; }
.proj-val.regimen { color: #e0e0e0; }
.proj-arrow { color: #333; font-size: 18px; }

/* Metrics */
.metric-item { margin: 20px 0; }
.metric-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 2px; }
.metric-name { font-family: 'DM Mono', monospace; font-size: 11px; letter-spacing: 2px; text-transform: uppercase; color: #e0e0e0; }
.metric-score { font-family: 'DM Mono', monospace; font-size: 16px; font-weight: 500; }
.metric-context { font-size: 12px; color: #444; margin-bottom: 6px; }
.metric-bar-wrap { position: relative; height: 20px; margin: 4px 0; }
.metric-bar-track { position: absolute; top: 9px; left: 0; right: 0; height: 2px; background: #1a1a1a; }
.metric-bar-dot { position: absolute; top: 4px; width: 12px; height: 12px; border-radius: 50%; background: #fff; transition: left 1s ease; }
.metric-bar-avg { position: absolute; top: 4px; width: 1px; height: 12px; background: #333; }
.metric-bar-labels { display: flex; justify-content: space-between; font-family: 'DM Mono', monospace; font-size: 9px; color: #333; letter-spacing: 1px; }
.metric-raw { font-family: 'DM Mono', monospace; font-size: 10px; color: #333; margin-top: 2px; }

/* Hero */
.hero-archetype { font-family: 'DM Mono', monospace; font-size: 12px; letter-spacing: 3px; color: #555; text-transform: uppercase; margin-bottom: 12px; }
.hero-opening { font-size: 18px; line-height: 1.5; margin-bottom: 12px; }
.hero-impression { font-family: 'DM Mono', monospace; font-size: 13px; color: #555; font-style: italic; }

/* Architecture */
.arch-label { font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 2px; color: #444; text-transform: uppercase; margin: 16px 0 8px; }
.arch-feature { font-weight: 500; margin-bottom: 2px; }
.arch-detail { font-size: 14px; color: #888; margin-bottom: 12px; line-height: 1.5; }
.leak-feature { color: #8a5a5a; font-weight: 500; margin-bottom: 2px; }

/* Optimization */
.opt-label { font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 2px; color: #444; text-transform: uppercase; margin: 16px 0 12px; }
.opt-item { display: flex; gap: 14px; margin-bottom: 16px; }
.opt-bump { font-family: 'DM Mono', monospace; font-size: 13px; color: #7abd7a; flex-shrink: 0; width: 40px; }
.opt-content {}
.opt-action { font-weight: 500; font-size: 14px; margin-bottom: 2px; }
.opt-detail { font-size: 13px; color: #888; }

/* Looksmaxxing */
.lm-item { background: #111; border-radius: 8px; padding: 16px; margin-bottom: 12px; border-left: 3px solid #333; }
.lm-item[data-roi="high"] { border-left-color: #7abd7a; }
.lm-item[data-roi="medium"] { border-left-color: #c9a84c; }
.lm-item[data-roi="low"] { border-left-color: #666; }
.lm-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.lm-technique { font-weight: 500; font-size: 14px; }
.lm-badges { display: flex; gap: 6px; }
.lm-badge { font-family: 'DM Mono', monospace; font-size: 9px; letter-spacing: 1px; padding: 2px 6px; border-radius: 3px; text-transform: uppercase; }
.lm-badge.roi-high { background: rgba(122,189,122,0.15); color: #7abd7a; }
.lm-badge.roi-medium { background: rgba(201,168,76,0.15); color: #c9a84c; }
.lm-badge.roi-low { background: rgba(102,102,102,0.15); color: #666; }
.lm-badge.evidence { background: rgba(255,255,255,0.05); color: #555; }
.lm-target { font-family: 'DM Mono', monospace; font-size: 10px; color: #555; margin-bottom: 6px; }
.lm-detail { font-size: 13px; color: #888; line-height: 1.5; }

/* Body fat ref */
.bf-ref { background: #0f0f0f; border-radius: 6px; padding: 14px 18px; margin-top: 16px; }
.bf-ref-title { font-family: 'DM Mono', monospace; font-size: 9px; letter-spacing: 2px; color: #444; margin-bottom: 8px; }
.bf-row { display: flex; justify-content: space-between; font-size: 13px; color: #555; padding: 2px 0; }

/* Best angle */
.angle-val { font-family: 'DM Mono', monospace; font-size: 20px; margin-bottom: 6px; }
.angle-note { font-size: 14px; color: #888; }

/* Personality */
.section-body { font-size: 14px; line-height: 1.7; color: #888; margin-top: 16px; }

/* Thirds bar */
.thirds-bar { display: flex; border-radius: 4px; overflow: hidden; height: 24px; font-family: 'DM Mono', monospace; font-size: 10px; margin: 8px 0; }
.thirds-seg { display: flex; align-items: center; justify-content: center; color: #555; }

/* Share / Actions */
.report-actions { display: flex; gap: 12px; justify-content: center; margin: 24px 0; }
.action-btn { background: transparent; color: #888; border: 1px solid #222; padding: 10px 24px; font-family: 'DM Mono', monospace; font-size: 12px; letter-spacing: 2px; cursor: pointer; transition: all 0.3s; border-radius: 4px; }
.action-btn:hover { border-color: #00ffaa; color: #00ffaa; }
.action-btn:active { transform: scale(0.97); }

/* Methodology */
.methodology { text-align: center; font-family: 'DM Mono', monospace; font-size: 10px; color: #333; line-height: 1.8; margin-top: 24px; max-width: 500px; }

/* Annotated photo */
.annotated-photo img { width: 100%; max-width: 500px; display: block; margin: 0 auto; border-radius: 6px; border: 1px solid #1a1a1a; }
</style>
</head>
<body>

<!-- UPLOAD -->
<div id="upload-screen" class="screen active">
  <div class="upload-zone" id="drop-zone">
    <h1>READ</h1>
    <p>Facial structure analysis powered by 68-point landmark detection</p>
    <button class="upload-btn" id="upload-btn" disabled onclick="document.getElementById('file-input').click()">Select Photo</button>
    <input type="file" id="file-input" accept="image/*">
    <div class="hint">or drag and drop an image</div>
    <div class="model-status" id="model-status">Loading detection models...</div>
  </div>
</div>

<!-- ANALYSIS -->
<div id="analysis-screen" class="screen">
  <div class="analysis-wrap" id="analysis-wrap">
    <img id="analysis-img" src="" alt="">
    <canvas id="overlay-canvas"></canvas>
    <div class="scan-overlay" id="scan-overlay"></div>
  </div>
  <div class="analysis-status" id="analysis-status">Detecting facial structure...</div>
  <div class="analysis-bar"><div class="analysis-bar-fill" id="analysis-bar"></div></div>
  <div class="error-msg" id="analysis-error" style="display:none"></div>
</div>

<!-- REPORT -->
<div id="report-screen" class="screen">
  <div class="report" id="report"></div>
</div>

<script>
// ===== GLOBALS =====
let modelsLoaded = false;
const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.14/model';

// ===== UTILITY =====
function esc(s) { if (!s) return ''; const d = document.createElement('div'); d.textContent = String(s); return d.innerHTML; }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }
function midpoint(a, b) { return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 }; }
function angleDeg(a, b) { return Math.atan2(b.y - a.y, b.x - a.x) * (180 / Math.PI); }

function scoreColor(s) {
  if (s >= 8) return '#7abd7a';
  if (s >= 6) return '#888';
  if (s >= 4) return '#c9a84c';
  return '#8a5a5a';
}

// Percentile (1-99) → Score (1.0-10.0)
function _pctToScore(pct) {
  pct = clamp(pct, 1, 99);
  if (pct <= 5) return 1.0 + (pct / 5) * 0.5;
  if (pct <= 15) return 1.5 + ((pct - 5) / 10) * 1.0;
  if (pct <= 30) return 2.5 + ((pct - 15) / 15) * 1.5;
  if (pct <= 50) return 4.0 + ((pct - 30) / 20) * 1.0;
  if (pct <= 70) return 5.0 + ((pct - 50) / 20) * 1.5;
  if (pct <= 85) return 6.5 + ((pct - 70) / 15) * 1.0;
  if (pct <= 93) return 7.5 + ((pct - 85) / 8) * 1.0;
  if (pct <= 97) return 8.5 + ((pct - 93) / 4) * 0.75;
  return 9.25 + ((pct - 97) / 2) * 0.75;
}

// ===== METRIC BAR (all use 1-10 scale) =====
function metricBarHTML(name, score, context, rawInfo) {
  // Map so 5 = 50% center
  const pos = score <= 5 ? ((score - 1) / 4) * 50 : 50 + ((score - 5) / 5) * 50;
  const dotColor = score >= 5 ? '#fff' : '#888';
  return `<div class="metric-item">
    <div class="metric-header">
      <span class="metric-name">${esc(name)}</span>
      <span class="metric-score" style="color:${scoreColor(score)}">${score.toFixed(1)}</span>
    </div>
    <div class="metric-context">${esc(context)}</div>
    <div class="metric-bar-wrap">
      <div class="metric-bar-track"></div>
      <div class="metric-bar-avg" style="left:50%"></div>
      <div class="metric-bar-dot" style="left:calc(${pos}% - 6px);background:${dotColor}"></div>
    </div>
    <div class="metric-bar-labels"><span>1</span><span>5</span><span>10</span></div>
    ${rawInfo ? `<div class="metric-raw">${esc(rawInfo)}</div>` : ''}
  </div>`;
}

// ===== LOAD MODELS =====
async function loadModels() {
  const status = document.getElementById('model-status');
  const btn = document.getElementById('upload-btn');
  try {
    await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
    status.textContent = 'Loading landmarks...';
    await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
    status.textContent = 'Loading expression model...';
    await faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL);
    status.textContent = 'Loading age/gender model...';
    await faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL);
    modelsLoaded = true;
    status.textContent = 'Models ready';
    status.classList.add('ready');
    btn.disabled = false;
  } catch (e) {
    status.textContent = 'Model load failed. Refresh to retry.';
  }
}
loadModels();

// ===== FILE INPUT + DRAG AND DROP =====
document.getElementById('file-input').addEventListener('change', e => {
  if (e.target.files[0] && modelsLoaded) analyze(e.target.files[0]);
});

const dropZone = document.getElementById('drop-zone');
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if (file && file.type.startsWith('image/') && modelsLoaded) analyze(file);
});

// ===== COMPUTE METRICS =====
function computeAllMetrics(landmarks, detection, age, gender, expressions) {
  const p = landmarks.positions;
  const faceW = dist(p[0], p[16]);
  const midlineTop = midpoint(p[21], p[22]);
  const chin = p[8];
  const faceH = dist(midlineTop, chin);

  // 1. SYMMETRY
  const midX = (p[27].x + p[30].x) / 2;
  const pairs = [[0,16],[1,15],[2,14],[3,13],[4,12],[5,11],[17,26],[18,25],[19,24],[20,23],[36,45],[37,44],[38,43],[39,42],[40,47],[41,46],[48,54],[49,53],[50,52]];
  let totalDev = 0;
  pairs.forEach(([l, r]) => {
    const lD = Math.abs(p[l].x - midX), rD = Math.abs(p[r].x - midX), avg = (lD + rD) / 2;
    if (avg > 0) totalDev += Math.abs(lD - rD) / avg;
  });
  const symmetryDev = totalDev / pairs.length;
  const symmetryScore = clamp(10 - symmetryDev * 40, 1, 10);

  // 2. FWHR
  const fwhrW = dist(p[1], p[15]), fwhrH = dist(midlineTop, p[51]);
  const fwhr = fwhrH > 0 ? fwhrW / fwhrH : 1.9;
  const idealFWHR = gender === 'male' ? 1.95 : 1.80;
  const fwhrScore = clamp(10 - Math.abs(fwhr - idealFWHR) * 28, 1, 10);

  // 3. CANTHAL TILT
  const ctL = angleDeg(p[36], p[39]), ctR = angleDeg(p[42], p[45]);
  const canthalTilt = -(ctL + ctR) / 2;
  const idealCT = gender === 'male' ? 5 : 6;
  const ctScore = clamp(10 - Math.abs(canthalTilt - idealCT) * 1.2, 1, 10);

  // 4. THIRDS
  const browY = midlineTop.y, noseY = p[33].y, chinY = chin.y;
  const bbox = detection.detection.box;
  const fhY = bbox.y;
  const uT = browY - fhY, mT = noseY - browY, lT = chinY - noseY, total = uT + mT + lT;
  const uPct = (uT/total)*100, mPct = (mT/total)*100, lPct = (lT/total)*100;
  const tDev = Math.abs(uPct-33.3)+Math.abs(mPct-33.3)+Math.abs(lPct-33.3);
  const thirdsScore = clamp(10 - tDev * 0.25, 1, 10);
  const thirdsBalance = tDev < 8 ? 'Balanced' : (lPct > 38 ? 'Bottom-heavy' : uPct > 38 ? 'Top-heavy' : 'Mid-heavy');

  // 5. EYE SPACING
  const lEC = midpoint(p[36], p[39]), rEC = midpoint(p[42], p[45]);
  const interoc = dist(lEC, rEC), esRatio = interoc / faceW;
  const esScore = clamp(10 - Math.abs(esRatio - 0.46) * 150, 1, 10);

  // 6. JAWLINE
  const jawAngle = (() => {
    const v1 = {x:p[4].x-p[8].x,y:p[4].y-p[8].y}, v2 = {x:p[12].x-p[8].x,y:p[12].y-p[8].y};
    const dot = v1.x*v2.x+v1.y*v2.y, m1 = Math.sqrt(v1.x**2+v1.y**2), m2 = Math.sqrt(v2.x**2+v2.y**2);
    return Math.acos(clamp(dot/(m1*m2),-1,1)) * (180/Math.PI);
  })();
  const idealJaw = gender === 'male' ? 128 : 135;
  const jawScore = clamp(10 - Math.abs(jawAngle - idealJaw) * 0.45, 1, 10);

  // 7. NOSE
  const noseW = dist(p[31], p[35]), noseRatio = interoc > 0 ? noseW / interoc : 0.7;
  const noseScore = clamp(10 - Math.abs(noseRatio - 0.65) * 45, 1, 10);

  // 8. MOUTH
  const mouthW = dist(p[48], p[54]), mouthRatio = mouthW / faceW;
  const mouthScore = clamp(10 - Math.abs(mouthRatio - 0.40) * 80, 1, 10);

  // 9. LIPS
  const uLipH = dist(p[51], p[62]), lLipH = dist(p[57], p[66]);
  const lipRatio = lLipH > 0 ? uLipH / lLipH : 0.7;
  const idealLip = gender === 'female' ? 0.75 : 0.70;
  const lipScore = clamp(10 - Math.abs(lipRatio - idealLip) * 30, 1, 10);

  // 10. GOLDEN RATIO
  const gr1 = faceH > 0 ? faceW / faceH : 1;
  const nCD = dist(p[33], chin), lCD = dist(p[57], chin);
  const gr3 = lCD > 0 ? nCD / lCD : 1;
  const grDev = (Math.abs(gr1 - 1.618) + Math.abs(interoc/faceW*2.5 - 1.618/2.5*2.5) + Math.abs(gr3 - 1.618)) / 3;
  const goldenScore = clamp(10 - grDev * 16, 1, 10);

  // 11. DIMORPHISM
  let dimorphism;
  if (gender === 'male') {
    const mF = clamp((fwhr-1.6)*6,1,10), mJ = clamp((150-jawAngle)*0.3,1,10);
    const bED = dist(midpoint(p[19],p[20]),midpoint(p[37],p[38]));
    const mB = clamp(10-bED/faceH*30,1,10);
    dimorphism = mF*0.4+mJ*0.4+mB*0.2;
  } else {
    const eH = (dist(p[37],p[41])+dist(p[38],p[40])+dist(p[43],p[47])+dist(p[44],p[46]))/4;
    const fE = clamp(eH/faceH*80,1,10), fL = clamp((uLipH+lLipH)/faceH*60,1,10), fJ = clamp((jawAngle-110)*0.25,1,10);
    dimorphism = fE*0.35+fL*0.35+fJ*0.3;
  }
  dimorphism = clamp(dimorphism,1,10);

  // 12. AGE
  const peak = gender === 'male' ? 30 : 24;
  const ageScore = clamp(10 - Math.abs(age - peak) / 6, 1, 10);

  // STRUCTURAL COMPOSITE
  const structural = (
    symmetryScore*0.20 + goldenScore*0.15 + fwhrScore*0.10 +
    ctScore*0.10 + thirdsScore*0.10 + jawScore*0.10 +
    esScore*0.075 + noseScore*0.075 + mouthScore*0.05 + lipScore*0.05
  );

  return {
    symmetry: { score: +symmetryScore.toFixed(1), deviation: +(symmetryDev*100).toFixed(1) },
    fwhr: { score: +fwhrScore.toFixed(1), value: +fwhr.toFixed(2) },
    canthalTilt: { score: +ctScore.toFixed(1), degrees: +canthalTilt.toFixed(1) },
    thirds: { score: +thirdsScore.toFixed(1), upper: +uPct.toFixed(0), mid: +mPct.toFixed(0), lower: +lPct.toFixed(0), balance: thirdsBalance },
    eyeSpacing: { score: +esScore.toFixed(1), ratio: +esRatio.toFixed(3) },
    jawline: { score: +jawScore.toFixed(1), angle: +jawAngle.toFixed(0) },
    nose: { score: +noseScore.toFixed(1), ratio: +noseRatio.toFixed(2) },
    mouth: { score: +mouthScore.toFixed(1), ratio: +mouthRatio.toFixed(2) },
    lips: { score: +lipScore.toFixed(1), ratio: +lipRatio.toFixed(2) },
    goldenRatio: { score: +goldenScore.toFixed(1), avgDeviation: +grDev.toFixed(3) },
    dimorphism: { score: +dimorphism.toFixed(1) },
    ageScore: { score: +ageScore.toFixed(1), detected: +age.toFixed(0) },
    structural: +structural.toFixed(2),
    gender, age: +age.toFixed(0), expressions, landmarks: p
  };
}

// ===== PHYSIOGNOMY =====
function computePhysiognomy(p, expressions, gender, metrics) {
  const happyBoost = (expressions.happy || 0) * 3;
  const angryPenalty = (expressions.angry || 0) * 3;
  const trust = clamp(5 + happyBoost - angryPenalty + (10 - metrics.jawline.score) * 0.15, 1, 10);
  const domFWHR = clamp((metrics.fwhr.value - 1.6) * 8, 1, 10);
  const domJaw = clamp((150 - metrics.jawline.angle) * 0.35, 1, 10);
  const dominance = clamp((domFWHR * 0.5 + domJaw * 0.5), 1, 10);
  const warmth = clamp(5 + happyBoost * 1.3 + (expressions.surprised || 0) * 1.5 - angryPenalty * 1.2, 1, 10);
  const competence = clamp((metrics.symmetry.score * 0.4 + clamp(metrics.age / 5, 1, 10) * 0.3 + dominance * 0.3), 1, 10);
  const approachability = clamp(trust * 0.4 + warmth * 0.4 + (10 - dominance) * 0.2, 1, 10);
  const threat = clamp(dominance * 0.5 + (10 - trust) * 0.3 + angryPenalty * 2, 1, 10);
  return { trustworthiness: +trust.toFixed(1), dominance: +dominance.toFixed(1), warmth: +warmth.toFixed(1), competence: +competence.toFixed(1), approachability: +approachability.toFixed(1), threat: +threat.toFixed(1) };
}

// ===== DRAW OVERLAY (brighter, more visible) =====
function drawOverlay(canvas, img, points, metrics) {
  const ctx = canvas.getContext('2d');
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;
  const fs = Math.max(13, canvas.width * 0.022);

  // Landmark dots only — small, subtle, no connecting lines
  points.forEach(pt => {
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fill();
  });

  // Key points slightly brighter (eyes, nose, mouth, jaw)
  const keyPts = [36,39,42,45,30,48,54,8,0,16];
  keyPts.forEach(i => {
    ctx.beginPath();
    ctx.arc(points[i].x, points[i].y, 3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fill();
  });

  // Labels — right side, clean white
  ctx.font = `500 ${fs}px DM Mono, monospace`;
  ctx.textAlign = 'left';
  const lx = points[16].x + 18;
  let ly = points[19].y;
  const gap = fs * 2.2;

  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.fillText(`SYM ${metrics.symmetry.score.toFixed(1)}`, lx, ly); ly += gap;
  ctx.fillText(`FWHR ${metrics.fwhr.value}`, lx, ly); ly += gap;
  ctx.fillText(`CT ${metrics.canthalTilt.degrees > 0 ? '+' : ''}${metrics.canthalTilt.degrees}°`, lx, ly); ly += gap;
  ctx.fillText(`JAW ${metrics.jawline.angle}°`, lx, ly); ly += gap;
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fillText(`GR ${metrics.goldenRatio.score.toFixed(1)}`, lx, ly); ly += gap;
  ctx.fillText(`DIM ${metrics.dimorphism.score.toFixed(1)}`, lx, ly);

  // Thirds — left side
  const fsS = Math.max(10, canvas.width * 0.015);
  ctx.font = `${fsS}px DM Mono, monospace`;
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.textAlign = 'right';
  const browY = Math.min(points[19].y, points[24].y), noseY = points[33].y;
  const tlx = points[0].x - 12;
  ctx.fillText(`U ${metrics.thirds.upper}%`, tlx, browY - 5);
  ctx.fillText(`M ${metrics.thirds.mid}%`, tlx, (browY + noseY) / 2);
  ctx.fillText(`L ${metrics.thirds.lower}%`, tlx, noseY + 15);
  ctx.textAlign = 'start';
}

function getAnnotatedImage(img, canvas) {
  const c = document.createElement('canvas'); c.width = canvas.width; c.height = canvas.height;
  const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0, c.width, c.height); ctx.drawImage(canvas, 0, 0);
  return c.toDataURL('image/jpeg', 0.92);
}

// ===== SCAN ANIMATION =====
function showScanEffect() {
  const overlay = document.getElementById('scan-overlay');
  overlay.innerHTML = `
    <div class="scan-vignette"></div>
    <div class="scan-bracket tl"></div>
    <div class="scan-bracket tr"></div>
    <div class="scan-bracket bl"></div>
    <div class="scan-bracket br"></div>
    <div class="scan-label" id="scan-phase">DETECTING FACE</div>
  `;
}

function updateScanPhase(text) {
  const el = document.getElementById('scan-phase');
  if (el) el.textContent = text;
}

// ===== SCREENS =====
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

// ===== MAIN PIPELINE =====
async function analyze(file) {
  showScreen('analysis-screen');
  const bar = document.getElementById('analysis-bar');
  const status = document.getElementById('analysis-status');
  const errorEl = document.getElementById('analysis-error');
  errorEl.style.display = 'none';
  bar.style.width = '5%';

  const img = document.getElementById('analysis-img');
  const canvas = document.getElementById('overlay-canvas');
  const dataUrl = await new Promise(r => { const fr = new FileReader(); fr.onload = () => r(fr.result); fr.readAsDataURL(file); });
  img.src = dataUrl;
  await new Promise(r => { img.onload = r; });

  // Scale if very large
  const maxDim = 1200;
  if (img.naturalWidth > maxDim || img.naturalHeight > maxDim) {
    const scale = maxDim / Math.max(img.naturalWidth, img.naturalHeight);
    const off = document.createElement('canvas');
    off.width = img.naturalWidth * scale; off.height = img.naturalHeight * scale;
    off.getContext('2d').drawImage(img, 0, 0, off.width, off.height);
    img.src = off.toDataURL('image/jpeg', 0.9);
    await new Promise(r => { img.onload = r; });
  }

  // Start scan animation
  showScanEffect();
  bar.style.width = '15%';
  status.textContent = 'Scanning facial structure...';

  // Detect
  let detection;
  try {
    detection = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceExpressions().withAgeAndGender();
    bar.style.width = '30%';
  } catch (e) {
    errorEl.textContent = 'Detection failed: ' + e.message;
    errorEl.style.display = 'block';
    return;
  }

  if (!detection) {
    errorEl.textContent = 'No face detected. Use a clear, front-facing photo.';
    errorEl.style.display = 'block';
    return;
  }

  updateScanPhase('MAPPING LANDMARKS');
  status.textContent = 'Computing structural metrics...';
  bar.style.width = '40%';

  const landmarks = detection.landmarks;
  const metrics = computeAllMetrics(landmarks, detection, detection.age, detection.gender, detection.expressions);
  const physiognomy = computePhysiognomy(landmarks.positions, detection.expressions, detection.gender, metrics);

  updateScanPhase('COMPUTING RATIOS');
  bar.style.width = '50%';

  // Draw overlay
  drawOverlay(canvas, img, landmarks.positions, metrics);
  const annotatedImgUrl = getAnnotatedImage(img, canvas);

  updateScanPhase('ANALYZING PRESENTATION');
  status.textContent = 'AI analyzing presentation...';
  bar.style.width = '55%';

  // Prepare base64
  const base64 = dataUrl.split(',')[1];
  const mediaType = dataUrl.split(';')[0].split(':')[1];

  // Call Claude
  let claudeData;
  try {
    const resp = await fetch('/api/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ image: base64, media_type: mediaType, metrics: { structural: metrics, physiognomy } })
    });
    bar.style.width = '85%';
    if (!resp.ok) { const err = await resp.json(); throw new Error(err.error || 'API error'); }
    claudeData = await resp.json();
  } catch (e) {
    errorEl.textContent = 'Analysis error: ' + e.message;
    errorEl.style.display = 'block';
    return;
  }

  updateScanPhase('BUILDING REPORT');
  bar.style.width = '95%';
  status.textContent = 'Building report...';

  // === PERCENTILE TO SCORE MAPPING ===
  // Maps Claude's percentile (1-99) to display score (1.0-10.0)
  function pctToScore(pct) { return _pctToScore(pct); }

  // Final score from Claude's percentile
  const rawPct = clamp(claudeData.attractiveness_percentile || 50, 1, 99);
  const finalScore = +pctToScore(rawPct).toFixed(1);

  // Presentation scores from percentiles
  const pres = claudeData.presentation_percentiles || {};
  const presScores = {};
  for (const [key, data] of Object.entries(pres)) {
    presScores[key] = { score: +pctToScore(data?.percentile || 50).toFixed(1), note: data?.note || '' };
  }
  const presAvg = Object.values(presScores).reduce((s, d) => s + d.score, 0) / Math.max(Object.keys(presScores).length, 1);

  // Bumps — convert percentile bumps to score bumps
  const todayBumpPct = (claudeData.today_moves || []).reduce((s, m) => s + (m.bump_percentile || 0), 0);
  const regimenBumpPct = (claudeData.regimen_moves || []).reduce((s, m) => s + (m.bump_percentile || 0), 0);
  const todayCeilPct = clamp(rawPct + todayBumpPct, rawPct, 99);
  const regimenCeilPct = clamp(todayCeilPct + regimenBumpPct, todayCeilPct, 99);
  const todayCeiling = +pctToScore(todayCeilPct).toFixed(1);
  const regimenCeiling = +pctToScore(regimenCeilPct).toFixed(1);

  bar.style.width = '100%';
  setTimeout(() => renderReport(metrics, physiognomy, claudeData, finalScore, todayCeiling, regimenCeiling, presAvg, presScores, rawPct, annotatedImgUrl), 500);
}

// ===== SCORE ANIMATION =====
function animateScore(el, target) {
  let current = 0;
  const step = target / 40;
  const interval = setInterval(() => {
    current += step;
    if (current >= target) { current = target; clearInterval(interval); }
    el.textContent = current.toFixed(1);
  }, 30);
}

// ===== RENDER REPORT =====
function renderReport(m, phys, cd, finalScore, todayCeil, regimenCeil, presAvg, presScores, rawPct, annotatedImgUrl) {
  showScreen('report-screen');
  const r = document.getElementById('report');
  let sn = 0;
  function sec(title, html) { sn++; return `<div class="section"><div class="section-num">${String(sn).padStart(2,'0')}</div><div class="section-title">${esc(title)}</div>${html}</div><div class="section-divider"></div>`; }
  let html = '';

  // ANNOTATED PHOTO
  html += `<div class="section"><div class="annotated-photo"><img src="${annotatedImgUrl}" alt="Analysis"></div></div>`;

  // 01 — ARCHETYPE
  html += sec('Read', `
    <div class="hero-archetype">${esc(cd.archetype || 'The Subject')}</div>
    <div class="hero-opening">${esc(cd.opening || '')}</div>
    <div class="hero-impression">${esc(cd.first_impression || '')}</div>
  `);

  // 02 — OVERALL SCORE
  html += sec('Overall Score', `
    <div class="big-score" id="score-display">0.0</div><span class="big-score-sub">/ 10</span>
    <div style="font-family:'DM Mono',monospace;font-size:12px;color:#444;margin-top:4px;letter-spacing:1px">${rawPct}th percentile</div>
    <div style="margin-top:20px">
      <div class="score-layer">
        <span class="score-layer-label">Structure</span>
        <div class="score-layer-bar"><div class="score-layer-fill" style="width:${m.structural*10}%;background:${scoreColor(m.structural)}"></div></div>
        <span class="score-layer-val">${m.structural.toFixed(1)}</span>
      </div>
      <div class="score-layer">
        <span class="score-layer-label">Presentation</span>
        <div class="score-layer-bar"><div class="score-layer-fill" style="width:${presAvg*10}%;background:${scoreColor(presAvg)}"></div></div>
        <span class="score-layer-val">${presAvg.toFixed(1)}</span>
      </div>
      <div class="score-layer">
        <span class="score-layer-label">Dimorphism</span>
        <div class="score-layer-bar"><div class="score-layer-fill" style="width:${m.dimorphism.score*10}%;background:${scoreColor(m.dimorphism.score)}"></div></div>
        <span class="score-layer-val">${m.dimorphism.score}</span>
      </div>
      <div class="score-layer">
        <span class="score-layer-label">Harmony</span>
        <div class="score-layer-bar"><div class="score-layer-fill" style="width:${((cd.harmony?.adjustment||0)+1)*50}%;background:${(cd.harmony?.adjustment||0)>=0?'#7abd7a':'#8a5a5a'}"></div></div>
        <span class="score-layer-val">${(cd.harmony?.adjustment||0)>0?'+':''}${(cd.harmony?.adjustment||0).toFixed(1)}</span>
      </div>
    </div>
    ${cd.percentile_reasoning ? `<div style="font-size:13px;color:#555;margin-top:16px;font-style:italic">${esc(cd.percentile_reasoning)}</div>` : ''}
  `);

  // 03 — PROJECTION
  html += sec('Score Projection', `
    <div class="projection">
      <div class="proj-node"><div class="proj-label">Current</div><div class="proj-val current">${finalScore.toFixed(1)}</div></div>
      <div class="proj-arrow">→</div>
      <div class="proj-node"><div class="proj-label">Today's Ceiling</div><div class="proj-val today">${todayCeil.toFixed(1)}</div></div>
      <div class="proj-arrow">→</div>
      <div class="proj-node"><div class="proj-label">90-Day Potential</div><div class="proj-val regimen">${regimenCeil.toFixed(1)}</div></div>
    </div>
  `);

  // 04 — STRUCTURAL ANALYSIS
  let metricsHTML = '';
  metricsHTML += metricBarHTML('Symmetry', m.symmetry.score, 'How closely left and right sides mirror each other', `${m.symmetry.deviation}% bilateral deviation`);
  metricsHTML += metricBarHTML('FWHR', m.fwhr.score, 'Face width relative to midface height — higher signals strength', `Measured: ${m.fwhr.value} · Ideal: ${m.gender==='male'?'1.95':'1.80'}`);
  metricsHTML += metricBarHTML('Canthal Tilt', m.canthalTilt.score, 'Eye corner angle — positive (upward outer corners) reads as more attractive', `${m.canthalTilt.degrees > 0 ? '+' : ''}${m.canthalTilt.degrees}° · Ideal: +${m.gender==='male'?'5':'6'}°`);

  metricsHTML += `<div class="metric-item">
    <div class="metric-header"><span class="metric-name">Thirds</span><span class="metric-score" style="color:${scoreColor(m.thirds.score)}">${m.thirds.score.toFixed(1)}</span></div>
    <div class="metric-context">Vertical face proportions — ideal is equal upper, middle, and lower thirds</div>
    <div class="thirds-bar">
      <div class="thirds-seg" style="width:${m.thirds.upper}%;background:#1a1a1a">U ${m.thirds.upper}%</div>
      <div class="thirds-seg" style="width:${m.thirds.mid}%;background:#141414">M ${m.thirds.mid}%</div>
      <div class="thirds-seg" style="width:${m.thirds.lower}%;background:#1a1a1a">L ${m.thirds.lower}%</div>
    </div>
    <div class="metric-raw">${esc(m.thirds.balance)} · Ideal: 33/33/33</div>
  </div>`;

  metricsHTML += metricBarHTML('Eye Spacing', m.eyeSpacing.score, 'Distance between eye centers relative to face width', `Ratio: ${m.eyeSpacing.ratio.toFixed(3)} · Ideal: 0.460`);
  metricsHTML += metricBarHTML('Jawline', m.jawline.score, `Chin angle — ${m.gender==='male'?'sharper (lower °) signals stronger jaw':'softer angles complement feminine features'}`, `${m.jawline.angle}° · Ideal: ${m.gender==='male'?'128':'135'}°`);
  metricsHTML += metricBarHTML('Nose Ratio', m.nose.score, 'Nose width relative to interocular distance', `Ratio: ${m.nose.ratio.toFixed(2)} · Ideal: 0.65`);
  metricsHTML += metricBarHTML('Mouth Ratio', m.mouth.score, 'Mouth width relative to face width', `Ratio: ${m.mouth.ratio.toFixed(2)} · Ideal: 0.40`);
  metricsHTML += metricBarHTML('Lip Ratio', m.lips.score, 'Upper to lower lip proportion balance', `Ratio: ${m.lips.ratio.toFixed(2)} · Ideal: ${m.gender==='female'?'0.75':'0.70'}`);
  metricsHTML += metricBarHTML('Golden Ratio', m.goldenRatio.score, 'How closely key proportions approach the golden ratio (1.618)', `Avg deviation: ${m.goldenRatio.avgDeviation}`);
  metricsHTML += metricBarHTML('Dimorphism', m.dimorphism.score, `Strength of ${m.gender==='male'?'masculine':'feminine'} features — jaw, brow, and eye area markers`, `${m.gender==='male'?'Masculine':'Feminine'} feature composite`);
  html += sec('Structural Analysis', metricsHTML);

  // 05 — PERSONALITY
  let physHTML = '';
  physHTML += metricBarHTML('Trust', phys.trustworthiness, 'How instinctively trustworthy the face appears to others', null);
  physHTML += metricBarHTML('Dominance', phys.dominance, 'Perceived authority and command presence', null);
  physHTML += metricBarHTML('Warmth', phys.warmth, 'Emotional openness and approachability others sense', null);
  physHTML += metricBarHTML('Competence', phys.competence, 'Perceived capability and reliability', null);
  physHTML += metricBarHTML('Approachable', phys.approachability, 'How comfortable strangers feel initiating contact', null);
  physHTML += metricBarHTML('Threat', phys.threat, 'Perceived danger level — lower is more approachable', null);
  physHTML += cd.personality_read ? `<div class="opt-label">Social Perception</div><div class="section-body">${esc(cd.personality_read)}</div>` : '';
  html += sec('Personality Profile', physHTML);

  // 06 — PRESENTATION
  let presHTML = '';
  const presMap = { skin_clarity: 'Skin Clarity', coloring_contrast: 'Coloring', hair: 'Hair', expression_quality: 'Expression', grooming: 'Grooming', photo_quality: 'Photo Quality' };
  const presCtx = { skin_clarity: 'Texture, evenness, pores, and blemishes', coloring_contrast: 'Contrast between features and skin tone', hair: 'Style, quality, and how it frames the face', expression_quality: 'How current expression affects attractiveness', grooming: 'Facial hair maintenance, brow shaping, upkeep', photo_quality: 'Lighting, angle, focus, and background' };
  for (const [key, label] of Object.entries(presMap)) {
    const data = presScores[key] || { score: 5, note: '' };
    const sc = data.score;
    const scPos = sc <= 5 ? ((sc - 1) / 4) * 50 : 50 + ((sc - 5) / 5) * 50;
    presHTML += `<div class="metric-item">
      <div class="metric-header"><span class="metric-name">${esc(label)}</span><span class="metric-score" style="color:${scoreColor(sc)}">${sc.toFixed(1)}</span></div>
      <div class="metric-context">${esc(presCtx[key])}</div>
      <div class="metric-bar-wrap">
        <div class="metric-bar-track"></div>
        <div class="metric-bar-avg" style="left:50%"></div>
        <div class="metric-bar-dot" style="left:calc(${scPos}% - 6px);background:${sc >= 5 ? '#fff' : '#888'}"></div>
      </div>
      <div class="metric-bar-labels"><span>1</span><span>5</span><span>10</span></div>
      ${data.note ? `<div class="metric-raw">${esc(data.note)}</div>` : ''}
    </div>`;
  }
  html += sec('Presentation Factors', presHTML);

  // 07 — ARCHITECTURE
  let archHTML = '<div class="arch-label">Strongest Architecture</div>';
  (cd.best_features || []).forEach(f => { archHTML += `<div class="arch-feature">${esc(f.feature)}</div><div class="arch-detail">${esc(f.detail)}</div>`; });
  archHTML += '<div class="arch-label">Structural Leaks</div>';
  (cd.leaks || []).forEach(f => { archHTML += `<div class="leak-feature">${esc(f.issue)}</div><div class="arch-detail">${esc(f.detail)}</div>`; });
  html += sec('Architecture', archHTML);

  // 08 — OPTIMIZATION
  let optHTML = '<div class="opt-label">Today — Immediate Impact</div>';
  let runningPct = rawPct;
  (cd.today_moves || []).forEach(mv => {
    const bpct = mv.bump_percentile || 0;
    const before = _pctToScore(runningPct);
    runningPct = clamp(runningPct + bpct, runningPct, 99);
    const after = _pctToScore(runningPct);
    const delta = (after - before).toFixed(1);
    optHTML += `<div class="opt-item"><div class="opt-bump">+${delta}</div><div class="opt-content"><div class="opt-action">${esc(mv.action)}</div><div class="opt-detail">${esc(mv.detail)}</div></div></div>`;
  });
  optHTML += '<div class="opt-label">90-Day Regimen</div>';
  (cd.regimen_moves || []).forEach(mv => {
    const bpct = mv.bump_percentile || 0;
    const before = _pctToScore(runningPct);
    runningPct = clamp(runningPct + bpct, runningPct, 99);
    const after = _pctToScore(runningPct);
    const delta = (after - before).toFixed(1);
    optHTML += `<div class="opt-item"><div class="opt-bump">+${delta}</div><div class="opt-content"><div class="opt-action">${esc(mv.action)}</div><div class="opt-detail">${esc(mv.detail)}</div></div></div>`;
  });
  optHTML += `<div class="bf-ref"><div class="bf-ref-title">Body Fat Reference — Optimal Facial Definition</div><div class="bf-row"><span>Men</span><span>10 – 15%</span></div><div class="bf-row"><span>Women</span><span>18 – 22%</span></div></div>`;
  html += sec('Optimization', optHTML);

  // 09 — LOOKSMAXXING
  if (cd.looksmaxxing && cd.looksmaxxing.length > 0) {
    let lmHTML = '<div style="font-size:13px;color:#555;margin-bottom:16px">Techniques matched to your specific structural profile, ranked by expected return on effort.</div>';
    cd.looksmaxxing.forEach(lm => {
      const roi = (lm.roi || 'medium').toLowerCase();
      const ev = (lm.evidence || 'moderate').toLowerCase();
      lmHTML += `<div class="lm-item" data-roi="${roi}">
        <div class="lm-header">
          <span class="lm-technique">${esc(lm.technique)}</span>
          <div class="lm-badges">
            <span class="lm-badge roi-${roi}">${roi} roi</span>
            <span class="lm-badge evidence">${ev}</span>
          </div>
        </div>
        <div class="lm-target">Targets: ${esc(lm.target)}</div>
        <div class="lm-detail">${esc(lm.detail)}</div>
      </div>`;
    });
    html += sec('Looksmaxxing', lmHTML);
  }

  // 10 — BEST ANGLE
  html += sec('Best Angle', `
    <div class="angle-val">${esc(cd.best_angle?.side || 'center')}</div>
    <div class="angle-note">${esc(cd.best_angle?.note || '')}</div>
  `);

  // ACTIONS
  html += `<div class="report-actions">
    <button class="action-btn" onclick="shareReport()">Share</button>
    <button class="action-btn" onclick="location.reload()">New Analysis</button>
  </div>`;

  // METHODOLOGY
  html += `<div class="methodology">This analysis evaluates structural and visual attributes from a single photograph using 68-point facial landmark detection, computed geometric ratios, and AI-assisted presentation assessment. Personality perception scores are based on Todorov's research on facial trait inference — they reflect how others perceive the face, not who the person is. Structural metrics are mathematically computed. Presentation scores are AI-assessed. All measurements are relative, not absolute. Looksmaxxing recommendations range from well-established to anecdotal — always research techniques independently before committing.</div>`;

  r.innerHTML = html;

  // Animate score
  setTimeout(() => {
    const scoreEl = document.getElementById('score-display');
    if (scoreEl) animateScore(scoreEl, finalScore);
  }, 300);
}

// ===== SHARE =====
async function shareReport() {
  const reportEl = document.getElementById('report');
  try {
    const canvas = await html2canvas(reportEl, { backgroundColor: '#0a0a0a', scale: 1, useCORS: true });
    canvas.toBlob(async blob => {
      if (navigator.share && navigator.canShare) {
        const file = new File([blob], 'read-analysis.png', { type: 'image/png' });
        try {
          await navigator.share({ title: 'READ — Facial Analysis', files: [file] });
          return;
        } catch (e) { /* fall through to download */ }
      }
      // Fallback: download
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'read-analysis.png';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 'image/png');
  } catch (e) {
    console.error('Share error:', e);
    alert('Share failed. Try screenshotting the report.');
  }
}
</script>
</body>
</html>
